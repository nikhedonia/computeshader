[{"/home/gaetano/projects/computeshader/src/index.js":"1","/home/gaetano/projects/computeshader/src/reportWebVitals.js":"2","/home/gaetano/projects/computeshader/src/App.js":"3","/home/gaetano/projects/computeshader/src/App.1.js":"4"},{"size":500,"mtime":1609020641370,"results":"5","hashOfConfig":"6"},{"size":362,"mtime":1607463278005,"results":"7","hashOfConfig":"6"},{"size":12861,"mtime":1609103010899,"results":"8","hashOfConfig":"6"},{"size":3978,"mtime":1609020674462,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},"1imn1ks",{"filePath":"13","messages":"14","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},{"filePath":"15","messages":"16","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":1,"source":"17"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"/home/gaetano/projects/computeshader/src/index.js",[],["20","21"],"/home/gaetano/projects/computeshader/src/reportWebVitals.js",[],"/home/gaetano/projects/computeshader/src/App.js",["22","23","24","25","26","27","28","29","30","31","32"],"'use strict';\n\nimport { useEffect, useRef } from \"react\";\n\nconst glsl = `\nconst vec4 bitEnc = vec4(1.,255.,65025.,16581375.);\nconst vec4 bitDec = 1./bitEnc;\nvec4 EncodeFloatRGBA (float v) {\n    vec4 enc = bitEnc * v;\n    enc = fract(enc);\n    enc -= enc.yzww * vec2(1./255., 0.).xxxy;\n    return enc;\n}\n\nfloat DecodeFloatRGBA (vec4 v) {\n    return dot(v, bitDec);\n}\n\n\nfloat shift_right (float v, float amt) { \n  v = floor(v) + 0.5; \n  return floor(v / exp2(amt)); \n}\nfloat shift_left (float v, float amt) { \n  return floor(v * exp2(amt) + 0.5); \n}\nfloat mask_last (float v, float bits) { \n  return mod(v, shift_left(1.0, bits)); \n}\nfloat extract_bits (float num, float from, float to) { \n  from = floor(from + 0.5); to = floor(to + 0.5); \n  return mask_last(shift_right(num, from), to - from); \n}\nvec4 encode_float (float val) { \n  if (val == 0.0) return vec4(0, 0, 0, 0); \n  float sign = val > 0.0 ? 0.0 : 1.0; \n  val = abs(val); \n  float exponent = floor(log2(val)); \n  float biased_exponent = exponent + 127.0; \n  float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0; \n  float t = biased_exponent / 2.0; \n  float last_bit_of_biased_exponent = fract(t) * 2.0; \n  float remaining_bits_of_biased_exponent = floor(t); \n  float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0; \n  float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0; \n  float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0; \n  float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0; \n  return vec4(byte4, byte3, byte2, byte1); \n}\n`\n\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n\nfunction batch(n, arr) {\n  const l = arr.length;\n  return range(l/n)\n    .map(x=> arr.slice(n*x, n*(x+1)));\n}\n\nfunction toGreyScale(arr) {\n  return batch(4, arr).map(chunk => {\n    const [r,g,b] = [...chunk];\n    return r;\n  });\n}\n\nfunction toRGBAScale(arr) {\n  return batch(4, arr).map(chunk => {\n    const [r,g,b,a] = [...chunk];\n    return {r,g,b,a};\n  });\n}\n\nfunction toGreyScaleMatrix(w, arr) {\n  return batch(w, toGreyScale(arr));\n}\n\nasync function fetchImage(url) {\n  const image = new Image();\n  image.src = url;\n  document.body.append(image);  \n  return new Promise((done, reject) => {\n    image.onerror = reject;\n    image.onload = done;\n  }).then(()=>image);\n}\n\n//\n// Initialize a texture and load an image.\n// When the image finished loading copy it into the texture.\n//\nasync function loadImage(gl, image) {\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // Because images have to be downloaded over the internet\n  // they might take a moment until they are ready.\n  // Until then put a single pixel in the texture so we can\n  // use it immediately. When the image has finished downloading\n  // we'll update the texture with the contents of the image.\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    gl.texImage2D(gl.TEXTURE_2D,  0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n    \n    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {\n      gl.generateMipmap(gl.TEXTURE_2D);    \n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    }\n\n  return texture;\n}\n\nfunction isPowerOf2(value) {\n  return (value & (value - 1)) == 0;\n}\n\n\n\nfunction image(name, image) {\n  return {\n    type: 'image',\n    name,\n    image\n  }\n}\n\nexport function uniform1f(name, value) {\n  return {\n    type: \"uniform1f\",\n    name,\n    value\n  };\n}\n\nexport function array2D(name, [w, h], data) {\n  return {\n    type: \"array2D\",\n    name,\n    w, \n    h,\n    data\n  };\n}\n\nfunction output(type, [w, h]) {\n  return {\n    type, //uint8|int32|float32\n    w, h,\n  };\n}\n\nfunction program([vs, fs], result, variables) {\n  return {\n    vs, \n    fs,\n    result,\n    variables\n  }\n}\n\n\nfunction bindProgram(gl, [vs, fs]) {\n  var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n  gl.shaderSource(vertexShader, vs);\n  gl.shaderSource(fragmentShader, fs);\n  gl.compileShader(vertexShader);\n\n  console.log(gl.getShaderInfoLog(vertexShader));  \n  \n  gl.compileShader(fragmentShader);\n  \n  console.log(gl.getShaderInfoLog(fragmentShader));  \n  \n  var p = gl.createProgram();\n  gl.attachShader(p, vertexShader);\n  gl.attachShader(p, fragmentShader);\n  gl.linkProgram(p);\n  gl.useProgram(p);\n\n  return p;\n}\n\nasync function createProgram(canvas, {result, vs, fs, variables}) {\n  canvas.width = result.w;\n  canvas.height = result.h;\n\n  const gl = canvas.getContext('webgl2');\n\n  const program = bindProgram(gl, [vs, fs]);\n  const positionLoc = gl.getAttribLocation(program, 'position');\n\n  bindPosition(gl, positionLoc);\n  let i = 0;\n  for (const tex of variables) {\n    switch (tex.type) {\n      case 'uniform1f':\n        bindUniform(gl, program, tex);\n        continue;\n      case 'array2D':\n        await bindArray2D(gl, program, tex, i);\n        continue;\n      case 'image':\n        await bindImage(gl, program, tex, i);\n        ++i;\n        continue;\n    }\n  }\n\n  return {gl, program};\n}\n\nfunction bindPosition (gl, position) {\n  // setup a full canvas clip space quad\n  var points = gl.createBuffer(gl.ARRAY_BUFFER);\n  gl.bindBuffer(gl.ARRAY_BUFFER, points);\n  gl.bufferData(\n    gl.ARRAY_BUFFER, \n    new Float32Array([\n      -1, 1, \n      1, 1, \n      1, -1,\n      -1, -1,\n    ]), \n    gl.STATIC_DRAW);\n  ;\n  gl.enableVertexAttribArray(position);\n  gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);\n}\n\nfunction bindUniform(gl, program, {name, value}){\n  const uniformLoc = gl.getUniformLocation(program, name);\n  gl.uniform1f(uniformLoc, value);  // tell the shader the src texture is on texture unit 0\n}\n\nfunction bindArray2D(gl, program, {name, data, w, h}, id){\n  const tex = gl.createTexture();\n  const uniformLoc = gl.getUniformLocation(program, name);\n  gl.bindTexture(gl.TEXTURE_2D, tex);\n  console.log({data})\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1); // see https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html\n  gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,                // mip level\n      gl.RGBA8,         // internal format\n      w,\n      h,\n      0,                // border\n      gl.RGBA,          // format\n      gl.UNSIGNED_BYTE, // type\n      data\n  );\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n  gl.uniform1i(uniformLoc, id);  // tell the shader the src texture is on texture unit 0\n}\n\nasync function bindImage(gl, program, {name, image}, id) {\n  gl.activeTexture(gl.TEXTURE0 + id);\n  const texture = await loadImage(gl, image);\n  console.log(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS, gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS));\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  const uniformLoc = gl.getUniformLocation(program, name);\n  console.log(name, id)\n  gl.uniform1i(uniformLoc, id);\n}\n\n\nasync function run(canvas, prog) {\n  const {gl} = await createProgram(canvas, prog);\n  const {result} = prog;\n\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT);\n  gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);  \n\n  return () => {\n    const data = new Uint8Array(result.w * result.h * 4);\n    gl.readPixels(0, 0, result.w, result.h, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n    switch (result.type) {\n      default:\n      case 'uint8':\n        return data;\n      case 'float32':\n        return new Float32Array(data.buffer)\n      case 'int32':\n        return new Int32Array(data.buffer)\n    }\n  }\n}\n\n\nconst vs = `\n  #version 300 es\n  in vec4 position;\n  void main() {\n    gl_Position = position;\n  }\n`.trim();\n\nconst fs = `\n  #version 300 es\n  precision mediump float;\n\n  float greyScale(vec3 x) {\n    return dot(x, vec3( 0.2125, 0.7154, 0.0721 ));\n  }\n\n  int bucketOf(vec3 x, vec3 y) {\n    float a = greyScale(x);\n    float b = greyScale(y);\n    int low = int(floor(a * 7.0));\n    int high = int(floor(b * 7.0)) << 3;\n    return low | high;\n  }\n\n  float entropyOf(int count, int total) {\n    if (count == 0) {\n      return 0.0;\n    } else {\n      float p = float(count) / (float(total));\n      return -p*log(p);\n    }\n  }\n\n  uniform float sp_width;\n  uniform float sp_height;\n\n  uniform float m_width;\n  uniform float m_height;\n\n  uniform sampler2D fixedTex;\n  uniform sampler2D movingTex;\n\n\n  out vec4 result;\n\n\n  void main() {\n\n    ivec2 offset = ivec2(\n      gl_FragCoord.x,\n      sp_height - gl_FragCoord.y\n    );\n\n    int buckets[64];\n    for (int i = 0; i < 64; ++i) {\n      buckets[i] = 0;\n    }\n\n    for (int i = 0; i < int(m_width); ++i) {\n      for (int j = 0; j < int(m_height); ++j) {\n        ivec2 uv = ivec2(i, j);\n        vec3 fixedImg = texelFetch(fixedTex,  offset+uv, 0).rgb;\n        vec3 movingImg = texelFetch(movingTex, uv, 0).rgb;\n        int bucketId = bucketOf(fixedImg, movingImg);\n        buckets[bucketId] += 1;\n      }\n    } \n\n    int total = 0;\n    for (int i = 0; i < 64; ++i) {\n      total += buckets[i];\n    }\n\n\n    float entropy  = 0.0;\n    for (int i = 0; i < 64; ++i) {\n      entropy += entropyOf(buckets[i], total);\n    }\n\n    vec3 color=vec3(entropy*0.2);\n\n\n    result = vec4(color, 1);\n  }\n`.trim();\n\n\nfunction SearchSpace({\n  fixedUrl = 'butterfly2.jpg', \n  movingUrl = 'butterfly3.jpg'\n}) {\n  const canvasRef = useRef(null);\n  const overlayCanvasRef = useRef(null);\n  const fixedImageRef = useRef(null);\n  const movingImageRef = useRef(null);\n\n  useEffect(()=>{\n    setTimeout(async () => {\n\n      const [fixed, moving] = [\n        fixedImageRef.current,\n        movingImageRef.current\n      ];\n\n      await new Promise(done => setTimeout(done, 300));\n      \n      const searchSpace = [\n        fixed.width - moving.width,\n        fixed.height - moving.height,\n      ];\n\n      let prog = program(\n        [vs, fs],\n        output(\n          'uint8', \n          searchSpace\n        ), \n        [\n          uniform1f(\"sp_width\", searchSpace[0]),\n          uniform1f(\"sp_height\", searchSpace[1]),\n          uniform1f(\"m_width\", moving.width),\n          uniform1f(\"m_height\", moving.height),\n          image(\"fixedTex\", fixed),\n          image(\"movingTex\", moving)\n        ]\n      )\n\n\n\n      const canvas = canvasRef.current;\n      const start = Date.now();\n      const getResult = await run(canvas, prog);\n      const end = Date.now();\n      const result =  getResult();\n      const readEnd = Date.now();\n\n      const time = end - start;\n      const uploadTime = readEnd - end;\n      const iterations = searchSpace[0]*searchSpace[1];\n      const pixelsCompared = iterations * fixed.width * fixed.height;\n      console.log({\n        time,\n        uploadTime,\n        searchSpace,\n        fixed: [fixed.width, fixed.height],\n        moving: [moving.width, moving.height],\n        iterations,\n        pixelsCompared,\n        itersPerSecond: iterations/time*1000,\n        pixelsPerSecond: pixelsCompared/time*1000,\n      })\n\n\n      const matrix = toGreyScaleMatrix(searchSpace[0], result);\n      const data = matrix\n        .flatMap( (row, y) => \n          row.map( (value, x) => ({value, y, x})))\n        .sort((a, b) => a.value - b.value);\n\n\n      console.log({topResults5: data.slice(0,5)});\n\n\n      // overlayCanvasRef.current.width = fixed.width;\n      // overlayCanvasRef.current.height = fixed.height;\n      // const ctx = overlayCanvasRef.current.getContext('2d');\n\n      // ctx.drawImage(fixed, 0, 0);\n      // ctx.drawImage(moving, data[0].x, data[0].y);\n\n    }, 0);\n  }, [fixedUrl, movingUrl]);\n\n  return (\n    <div>\n      <div style={{display:'flex'}} >\n        <div>\n          <h2>Fixed Image (haystack)</h2>\n          <img src={fixedUrl} ref={fixedImageRef} />\n        </div>\n        <div>\n          <h2>Moving Image (needle)</h2>\n          <img src={movingUrl} ref={movingImageRef} />\n        </div>\n        <div>\n          <h2>SearchSpace (darker is better) </h2>\n          <canvas ref={canvasRef} />\n        </div>\n        {/*<canvas ref={overlayCanvasRef} />*/}\n        \n      </div>\n    </div>\n  )\n}\n\nexport default function App() {\n  return (\n    <div>\n      <h1> Image Alignment with WebGL </h1>\n      <div>\n        Goal: find \"moving image\" inside \"fixed image\".<br/>\n\n        SearchSpace visualization shows how good the images are aligned at each x-y coordinate.\n        Darker is better.<br/>\n\n        Open console for performance metrics and results (ctrl+shift+i)\n      </div>\n      <SearchSpace fixedUrl=\"butterfly2.jpg\" movingUrl=\"butterfly3.jpg\" />\n      <SearchSpace fixedUrl=\"butterfly2.jpg\" movingUrl=\"butterfly4.jpg\" />\n      <SearchSpace fixedUrl=\"butterfly2.jpg\" movingUrl=\"butterfly5.jpg\" />\n    </div>\n  );  \n}","/home/gaetano/projects/computeshader/src/App.1.js",["33"],{"ruleId":"34","replacedBy":"35"},{"ruleId":"36","replacedBy":"37"},{"ruleId":"38","severity":1,"message":"39","line":1,"column":1,"nodeType":"40","messageId":"41","endLine":1,"endColumn":14,"fix":"42"},{"ruleId":"43","severity":1,"message":"44","line":5,"column":7,"nodeType":"45","messageId":"46","endLine":5,"endColumn":11},{"ruleId":"43","severity":1,"message":"47","line":64,"column":14,"nodeType":"45","messageId":"46","endLine":64,"endColumn":15},{"ruleId":"43","severity":1,"message":"48","line":64,"column":16,"nodeType":"45","messageId":"46","endLine":64,"endColumn":17},{"ruleId":"43","severity":1,"message":"49","line":69,"column":10,"nodeType":"45","messageId":"46","endLine":69,"endColumn":21},{"ruleId":"43","severity":1,"message":"50","line":80,"column":16,"nodeType":"45","messageId":"46","endLine":80,"endColumn":26},{"ruleId":"51","severity":1,"message":"52","line":119,"column":32,"nodeType":"53","messageId":"54","endLine":119,"endColumn":34},{"ruleId":"55","severity":1,"message":"56","line":201,"column":5,"nodeType":"57","messageId":"58","endLine":212,"endColumn":6},{"ruleId":"43","severity":1,"message":"59","line":394,"column":9,"nodeType":"45","messageId":"46","endLine":394,"endColumn":25},{"ruleId":"60","severity":1,"message":"61","line":480,"column":11,"nodeType":"62","endLine":480,"endColumn":53},{"ruleId":"60","severity":1,"message":"61","line":484,"column":11,"nodeType":"62","endLine":484,"endColumn":55},{"ruleId":"43","severity":1,"message":"63","line":113,"column":7,"nodeType":"45","messageId":"46","endLine":113,"endColumn":21},"no-native-reassign",["64"],"no-negated-in-lhs",["65"],"strict","'use strict' is unnecessary inside of modules.","ExpressionStatement","module",{"range":"66","text":"67"},"no-unused-vars","'glsl' is assigned a value but never used.","Identifier","unusedVar","'g' is assigned a value but never used.","'b' is assigned a value but never used.","'toRGBAScale' is defined but never used.","'fetchImage' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","'overlayCanvasRef' is assigned a value but never used.","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","JSXOpeningElement","'max_iterations' is assigned a value but never used.","no-global-assign","no-unsafe-negation",[0,13],""]