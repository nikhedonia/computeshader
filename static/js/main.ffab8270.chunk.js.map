{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["batch","n","arr","Array","keys","range","length","map","x","slice","toGreyScaleMatrix","w","chunk","r","toGreyScale","loadImage","gl","image","a","texture","createTexture","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","isPowerOf2","width","height","generateMipmap","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","value","name","type","uniform1f","output","h","program","result","variables","vs","fs","bindProgram","vertexShader","createShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","shaderSource","compileShader","console","log","getShaderInfoLog","p","createProgram","attachShader","linkProgram","useProgram","canvas","getContext","positionLoc","getAttribLocation","bindPosition","i","tex","bindUniform","bindArray2D","bindImage","position","points","createBuffer","ARRAY_BUFFER","bindBuffer","bufferData","Float32Array","STATIC_DRAW","enableVertexAttribArray","vertexAttribPointer","FLOAT","uniformLoc","getUniformLocation","id","data","pixelStorei","UNPACK_ALIGNMENT","RGBA8","NEAREST","TEXTURE_MAG_FILTER","uniform1i","activeTexture","TEXTURE0","MAX_COMBINED_TEXTURE_IMAGE_UNITS","getParameter","run","prog","clearColor","clear","COLOR_BUFFER_BIT","drawArrays","TRIANGLE_FAN","Uint8Array","readPixels","buffer","Int32Array","trim","SearchSpace","fixedUrl","movingUrl","canvasRef","useRef","fixedImageRef","movingImageRef","useState","amplification","setAmplification","firstRender","setFirstRender","results","setResults","useEffect","setTimeout","current","fixed","moving","Promise","done","searchSpace","start","Date","now","getResult","end","readEnd","time","uploadTime","iterations","pixelsCompared","benchmark","itersPerSecond","pixelsPerSecond","matrix","flatMap","row","y","sort","b","topResults5","matches","style","display","src","ref","onChange","e","target","defaultValue","fontSize","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ffab8270.chunk.js","sourcesContent":["'use strict';\n\nimport { useEffect, useRef, useState } from \"react\";\n\nconst glsl = `\nconst vec4 bitEnc = vec4(1.,255.,65025.,16581375.);\nconst vec4 bitDec = 1./bitEnc;\nvec4 EncodeFloatRGBA (float v) {\n    vec4 enc = bitEnc * v;\n    enc = fract(enc);\n    enc -= enc.yzww * vec2(1./255., 0.).xxxy;\n    return enc;\n}\n\nfloat DecodeFloatRGBA (vec4 v) {\n    return dot(v, bitDec);\n}\n\n\nfloat shift_right (float v, float amt) { \n  v = floor(v) + 0.5; \n  return floor(v / exp2(amt)); \n}\nfloat shift_left (float v, float amt) { \n  return floor(v * exp2(amt) + 0.5); \n}\nfloat mask_last (float v, float bits) { \n  return mod(v, shift_left(1.0, bits)); \n}\nfloat extract_bits (float num, float from, float to) { \n  from = floor(from + 0.5); to = floor(to + 0.5); \n  return mask_last(shift_right(num, from), to - from); \n}\nvec4 encode_float (float val) { \n  if (val == 0.0) return vec4(0, 0, 0, 0); \n  float sign = val > 0.0 ? 0.0 : 1.0; \n  val = abs(val); \n  float exponent = floor(log2(val)); \n  float biased_exponent = exponent + 127.0; \n  float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0; \n  float t = biased_exponent / 2.0; \n  float last_bit_of_biased_exponent = fract(t) * 2.0; \n  float remaining_bits_of_biased_exponent = floor(t); \n  float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0; \n  float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0; \n  float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0; \n  float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0; \n  return vec4(byte4, byte3, byte2, byte1); \n}\n`\n\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n\nfunction batch(n, arr) {\n  const l = arr.length;\n  return range(l/n)\n    .map(x=> arr.slice(n*x, n*(x+1)));\n}\n\nfunction toGreyScale(arr) {\n  return batch(4, arr).map(chunk => {\n    const [r,g,b] = [...chunk];\n    return r;\n  });\n}\n\nfunction toRGBAScale(arr) {\n  return batch(4, arr).map(chunk => {\n    const [r,g,b,a] = [...chunk];\n    return {r,g,b,a};\n  });\n}\n\nfunction toGreyScaleMatrix(w, arr) {\n  return batch(w, toGreyScale(arr));\n}\n\nasync function fetchImage(url) {\n  const image = new Image();\n  image.src = url;\n  document.body.append(image);  \n  return new Promise((done, reject) => {\n    image.onerror = reject;\n    image.onload = done;\n  }).then(()=>image);\n}\n\n//\n// Initialize a texture and load an image.\n// When the image finished loading copy it into the texture.\n//\nasync function loadImage(gl, image) {\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  // Because images have to be downloaded over the internet\n  // they might take a moment until they are ready.\n  // Until then put a single pixel in the texture so we can\n  // use it immediately. When the image has finished downloading\n  // we'll update the texture with the contents of the image.\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    gl.texImage2D(gl.TEXTURE_2D,  0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n    \n    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {\n      gl.generateMipmap(gl.TEXTURE_2D);    \n    } else {\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n    }\n\n  return texture;\n}\n\nfunction isPowerOf2(value) {\n  return (value & (value - 1)) == 0;\n}\n\n\n\nfunction image(name, image) {\n  return {\n    type: 'image',\n    name,\n    image\n  }\n}\n\nexport function uniform1f(name, value) {\n  return {\n    type: \"uniform1f\",\n    name,\n    value\n  };\n}\n\nexport function array2D(name, [w, h], data) {\n  return {\n    type: \"array2D\",\n    name,\n    w, \n    h,\n    data\n  };\n}\n\nfunction output(type, [w, h]) {\n  return {\n    type, //uint8|int32|float32\n    w, h,\n  };\n}\n\nfunction program([vs, fs], result, variables) {\n  return {\n    vs, \n    fs,\n    result,\n    variables\n  }\n}\n\n\nfunction bindProgram(gl, [vs, fs]) {\n  var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n  gl.shaderSource(vertexShader, vs);\n  gl.shaderSource(fragmentShader, fs);\n  gl.compileShader(vertexShader);\n\n  console.log(gl.getShaderInfoLog(vertexShader));  \n  \n  gl.compileShader(fragmentShader);\n  \n  console.log(gl.getShaderInfoLog(fragmentShader));  \n  \n  var p = gl.createProgram();\n  gl.attachShader(p, vertexShader);\n  gl.attachShader(p, fragmentShader);\n  gl.linkProgram(p);\n  gl.useProgram(p);\n\n  return p;\n}\n\nasync function createProgram(canvas, {result, vs, fs, variables}) {\n  canvas.width = result.w;\n  canvas.height = result.h;\n\n  const gl = canvas.getContext('webgl2');\n\n  const program = bindProgram(gl, [vs, fs]);\n  const positionLoc = gl.getAttribLocation(program, 'position');\n\n  bindPosition(gl, positionLoc);\n  let i = 0;\n  for (const tex of variables) {\n    switch (tex.type) {\n      case 'uniform1f':\n        bindUniform(gl, program, tex);\n        continue;\n      case 'array2D':\n        await bindArray2D(gl, program, tex, i);\n        continue;\n      case 'image':\n        await bindImage(gl, program, tex, i);\n        ++i;\n        continue;\n    }\n  }\n\n  return {gl, program};\n}\n\nfunction bindPosition (gl, position) {\n  // setup a full canvas clip space quad\n  var points = gl.createBuffer(gl.ARRAY_BUFFER);\n  gl.bindBuffer(gl.ARRAY_BUFFER, points);\n  gl.bufferData(\n    gl.ARRAY_BUFFER, \n    new Float32Array([\n      -1, 1, \n      1, 1, \n      1, -1,\n      -1, -1,\n    ]), \n    gl.STATIC_DRAW);\n  ;\n  gl.enableVertexAttribArray(position);\n  gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);\n}\n\nfunction bindUniform(gl, program, {name, value}){\n  const uniformLoc = gl.getUniformLocation(program, name);\n  gl.uniform1f(uniformLoc, value);  // tell the shader the src texture is on texture unit 0\n}\n\nfunction bindArray2D(gl, program, {name, data, w, h}, id){\n  const tex = gl.createTexture();\n  const uniformLoc = gl.getUniformLocation(program, name);\n  gl.bindTexture(gl.TEXTURE_2D, tex);\n  console.log({data})\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1); // see https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html\n  gl.texImage2D(\n      gl.TEXTURE_2D,\n      0,                // mip level\n      gl.RGBA8,         // internal format\n      w,\n      h,\n      0,                // border\n      gl.RGBA,          // format\n      gl.UNSIGNED_BYTE, // type\n      data\n  );\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n  gl.uniform1i(uniformLoc, id);  // tell the shader the src texture is on texture unit 0\n}\n\nasync function bindImage(gl, program, {name, image}, id) {\n  gl.activeTexture(gl.TEXTURE0 + id);\n  const texture = await loadImage(gl, image);\n  console.log(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS, gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS));\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  const uniformLoc = gl.getUniformLocation(program, name);\n  console.log(name, id)\n  gl.uniform1i(uniformLoc, id);\n}\n\n\nasync function run(canvas, prog) {\n  const {gl} = await createProgram(canvas, prog);\n  const {result} = prog;\n\n  gl.clearColor(0.0, 0.0, 0.0, 1.0);\n  gl.clear(gl.COLOR_BUFFER_BIT);\n  gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);  \n\n  return () => {\n    const data = new Uint8Array(result.w * result.h * 4);\n    gl.readPixels(0, 0, result.w, result.h, gl.RGBA, gl.UNSIGNED_BYTE, data);\n\n    switch (result.type) {\n      default:\n      case 'uint8':\n        return data;\n      case 'float32':\n        return new Float32Array(data.buffer)\n      case 'int32':\n        return new Int32Array(data.buffer)\n    }\n  }\n}\n\n\nconst vs = `\n  #version 300 es\n  in vec4 position;\n  void main() {\n    gl_Position = position;\n  }\n`.trim();\n\nconst fs = `\n  #version 300 es\n  precision mediump float;\n\n  float greyScale(vec3 x) {\n    return dot(x, vec3( 0.2125, 0.7154, 0.0721 ));\n  }\n\n  int bucketOf(vec3 x, vec3 y) {\n    float a = greyScale(x);\n    float b = greyScale(y);\n    int low = int(floor(a * 7.0));\n    int high = int(ceil(b * 7.0)) << 3;\n    return low | high;\n  }\n\n  float entropyOf(int count, int total) {\n    if (count == 0) {\n      return 0.0;\n    } else {\n      float p = float(count) / (float(total));\n      return -p*log(p);\n    }\n  }\n\n  uniform float amplification;\n  uniform float sp_width;\n  uniform float sp_height;\n\n  uniform float m_width;\n  uniform float m_height;\n\n  uniform sampler2D fixedTex;\n  uniform sampler2D movingTex;\n\n\n  out vec4 result;\n\n  float jointEntropy(ivec2 offset1, ivec2 offset2, sampler2D a, sampler2D b) {\n\n    int buckets[64];\n    for (int i = 0; i < 64; ++i) {\n      buckets[i] = 0;\n    }\n\n    for (int i = 0; i < int(m_width); ++i) {\n      for (int j = 0; j < int(m_height); ++j) {\n        ivec2 uv = ivec2(i, j);\n        vec3 fixedImg = texelFetch(a,  offset1+uv, 0).rgb;\n        vec3 movingImg = texelFetch(b, offset2+uv, 0).rgb;\n        int bucketId = bucketOf(fixedImg, movingImg);\n        buckets[bucketId] += 1;\n      }\n    } \n\n    int total = 0;\n    for (int i = 0; i < 64; ++i) {\n      total += buckets[i];\n    }\n\n\n    float entropy  = 0.0;\n    for (int i = 0; i < 64; ++i) {\n      entropy += entropyOf(buckets[i], total);\n    }\n\n    return entropy;\n  }\n\n\n  void main() {\n\n    ivec2 offset = ivec2(\n      gl_FragCoord.x,\n      sp_height - gl_FragCoord.y\n    );\n\n    float a = jointEntropy(offset, offset, fixedTex, fixedTex); \n    float b = jointEntropy(ivec2(0,0), ivec2(0,0), movingTex, movingTex); \n    float ab = jointEntropy(offset, ivec2(0,0), fixedTex, movingTex);\n    float totalEntropy = a + b;\n    float entropy = (totalEntropy - ab) / totalEntropy * 2.0;\n\n    vec3 color=vec3(entropy*amplification);\n\n    result = vec4(color, 1);\n  }\n`.trim();\n\n\nfunction SearchSpace({\n  fixedUrl = 'butterfly2.jpg', \n  movingUrl = 'butterfly3.jpg'\n}) {\n  const canvasRef = useRef(null);\n  const overlayCanvasRef = useRef(null);\n  const fixedImageRef = useRef(null);\n  const movingImageRef = useRef(null);\n  const [amplification, setAmplification] = useState(1.0);\n  const [firstRender, setFirstRender] = useState(true);\n  const [results, setResults] = useState(null);\n\n  useEffect(()=>{\n    setTimeout(async () => {\n\n      const [fixed, moving] = [\n        fixedImageRef.current,\n        movingImageRef.current\n      ];\n\n      // hack to ensure images are loaded\n      if (firstRender) {\n        await new Promise(done => setTimeout(done, 300));\n        setFirstRender(false);\n      }\n      \n      const searchSpace = [\n        fixed.width - moving.width,\n        fixed.height - moving.height,\n      ];\n\n      let prog = program(\n        [vs, fs],\n        output(\n          'uint8', \n          searchSpace\n        ), \n        [\n          uniform1f(\"amplification\", amplification),\n          uniform1f(\"sp_width\", searchSpace[0]),\n          uniform1f(\"sp_height\", searchSpace[1]),\n          uniform1f(\"m_width\", moving.width),\n          uniform1f(\"m_height\", moving.height),\n          image(\"fixedTex\", fixed),\n          image(\"movingTex\", moving)\n        ]\n      )\n\n\n\n      const canvas = canvasRef.current;\n      const start = Date.now();\n      const getResult = await run(canvas, prog);\n      const end = Date.now();\n      const result =  getResult();\n      const readEnd = Date.now();\n\n      const time = end - start;\n      const uploadTime = readEnd - end;\n      const iterations = searchSpace[0]*searchSpace[1];\n      const pixelsCompared = iterations * fixed.width * fixed.height;\n      const benchmark = {\n        time,\n        uploadTime,\n        searchSpace,\n        fixed: [fixed.width, fixed.height],\n        moving: [moving.width, moving.height],\n        iterations,\n        pixelsCompared,\n        itersPerSecond: iterations/time*1000,\n        pixelsPerSecond: pixelsCompared/time*1000,\n      }\n\n      console.log(benchmark);\n\n      const matrix = toGreyScaleMatrix(searchSpace[0], result);\n      const data = matrix\n        .flatMap( (row, y) => \n          row.map( (value, x) => ({value,  y:searchSpace[1]-y, x})))\n        .sort((a, b) => b.value - a.value);\n\n\n      console.log({topResults5: data.slice(0,5)});\n\n      setResults({\n        benchmark,\n        matches: data.slice(0,5)\n      });\n\n\n      // overlayCanvasRef.current.width = fixed.width;\n      // overlayCanvasRef.current.height = fixed.height;\n      // const ctx = overlayCanvasRef.current.getContext('2d');\n\n      // ctx.drawImage(fixed, 0, 0);\n      // ctx.drawImage(moving, data[0].x, data[0].y);\n\n    }, 0);\n  }, [amplification, fixedUrl, movingUrl]);\n\n  return (\n    <div>\n      <div style={{display:'flex'}} >\n        <div>\n          <h2>Fixed Image (haystack)</h2>\n          <img src={fixedUrl} ref={fixedImageRef} />\n        </div>\n        <div>\n          <h2>Moving Image (needle)</h2>\n          <img src={movingUrl} ref={movingImageRef} />\n        </div>\n        <div>\n          <h2>SearchSpace (Lighter is better) </h2>\n          <canvas ref={canvasRef} />\n          <div>\n            <label> Amplification:\n              <input onChange={e=>setAmplification(e.target.value)} type=\"number\" defaultValue=\"1.0\" value={amplification}/>\n            </label>\n          </div>\n          {results && (\n            <div style={{fontSize:\"0.8em\"}}>\n              <h3>Results</h3>\n\n              <table>\n                <thead>\n                  <tr>\n                    <th>Name</th>\n                    <th>Value</th>\n                  </tr>\n                </thead>\n                <tbody>\n                <tr>\n                    <td>Compute Time</td>\n                    <td>{results.benchmark.time}</td>\n                  </tr>\n                  <tr>\n                    <td>Data Extraction Time</td>\n                    <td>{results.benchmark.uploadTime}</td>\n                  </tr>\n                  {results.matches.map( ({x,y,value}, i) => (\n                    <tr key={i}>\n                      <td>match {i+1}</td>\n                      <td>offset: {x} | {y} ({value})</td>\n                    </tr>\n                  ))}\n                </tbody>\n              </table>\n          </div>\n          )}\n        </div>\n        \n      </div>\n    </div>\n  )\n}\n\nexport default function App() {\n  return (<>\n    <h1> Image Alignment with WebGL </h1>\n    <div>\n      Goal: find \"moving image\" inside \"fixed image\"\n      SearchSpace visualization shows how good the score of each x-y offset. \n      Lighter is better.\n      Score is determined by computing the joint entropy (mutual information) between fixed and moving image.\n\n      Open console for performance metrics and results (ctrl+shift+i)\n    </div>\n    <div>\n      <SearchSpace fixedUrl=\"butterfly2.jpg\" movingUrl=\"butterfly3.jpg\" />\n      <SearchSpace fixedUrl=\"butterfly2.jpg\" movingUrl=\"butterfly4.jpg\" />\n      <SearchSpace fixedUrl=\"butterfly2.jpg\" movingUrl=\"butterfly5.jpg\" />\n    </div>\n  </>);  \n}","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}